from __future__ import annotations

import os
import re
from typing import Dict, List, Any
import difflib

REQUEST_TYPE_RE = re.compile(r"\\?Illuminate\\\\Http\\\\Request|Request\b")
METHOD_SIG_RE = re.compile(r"function\s+([A-Za-z_][A-Za-z0-9_]*)\s*\((?P<params>[^)]*)\)")
REQUEST_PARAM_RE = re.compile(r"(?P<type>\\?Illuminate\\\\Http\\\\Request|Request)\s+\$(?P<var>[a-zA-Z_][a-zA-Z0-9_]*)")
VALIDATE_CALL_RE = re.compile(r"\$([a-zA-Z_][a-zA-Z0-9_]*)\s*->\s*validate\s*\(\s*\[", re.MULTILINE)
VALIDATE_ANY_RE = re.compile(r"\$([a-zA-Z_][a-zA-Z0-9_]*)\s*->\s*validate\s*\(", re.MULTILINE)
USE_REQUESTS_RE = re.compile(r"^use\s+App\\\\Http\\\\Requests\\\\", re.MULTILINE)
PHP_OPEN_NAMESPACE_RE = re.compile(r"^namespace\s+[^;]+;", re.MULTILINE)


def _preferred_request_class(method_name: str | None, controller_name: str | None) -> str:
    if method_name:
        base = method_name[0].upper() + method_name[1:] + "Request"
    elif controller_name:
        base = controller_name + "Request"
    else:
        base = "AutoGeneratedRequest"
    return base


def _infer_controller_name(content: str) -> str | None:
    m = re.search(r"class\s+([A-Za-z_][A-Za-z0-9_]*)Controller\b", content)
    return m.group(1) if m else None


def build_refactor_plan(project_root: str, validation_summary: Dict[str, Any]) -> Dict[str, Any]:
    plan: Dict[str, Any] = {"items": []}
    for r in validation_summary.get("results", []) or []:
        if not r.get("issues_found"):
            continue
        file_path = r.get("file")
        try:
            with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
                content = f.read()
        except Exception:
            continue
        controller = _infer_controller_name(content)
        method_hits = r.get("inline_validation", []) or []
        for hit in method_hits:
            method = hit.get("method")
            request_class = _preferred_request_class(method, controller)
            fqcn = f"App\\\\Http\\\\Requests\\\\{request_class}"
            plan["items"].append({
                "file": file_path,
                "method": method,
                "request_class": request_class,
                "fqcn": fqcn,
            })
    return plan


def _ensure_use_statement(content: str, fqcn: str) -> str:
    if USE_REQUESTS_RE.search(content):
        # If some Requests use exists, just add another use if missing
        if f"use {fqcn};" in content:
            return content
        # Insert after last use App\\Http\\Requests line
        lines = content.splitlines(True)
        insert_at = 0
        for i, ln in enumerate(lines):
            if ln.startswith("use App\\\\Http\\\\Requests\\\\"):
                insert_at = i + 1
        lines.insert(insert_at, f"use {fqcn};\n")
        return "".join(lines)
    # Insert after namespace
    m = PHP_OPEN_NAMESPACE_RE.search(content)
    if not m:
        return content
    idx = m.end()
    return content[:idx] + f"\nuse {fqcn};\n" + content[idx:]


def _replace_request_type_in_signature(sig: str, request_class: str) -> str:
    # Replace Request $var with RequestClass $var
    return REQUEST_PARAM_RE.sub(lambda m: f"{request_class} ${m.group('var')}", sig)


def _refactor_method_body(body: str, request_var: str) -> str:
    # Replace $request->validate(...) with $request->validated()
    # Remove array rules; simplest is to replace validate( ... ) with validated()
    def repl_validate(match: re.Match) -> str:
        return f"${request_var}->validated()"
    body = VALIDATE_ANY_RE.sub(repl_validate, body)
    return body


def create_controller_refactor_diff(content: str, request_class: str) -> str:
    # Add use statement
    fqcn = f"App\\\\Http\\\\Requests\\\\{request_class}"
    content2 = _ensure_use_statement(content, fqcn)

    # Update method signatures and bodies
    out = content2
    def replace_method(m: re.Match) -> str:
        full = m.group(0)
        name = m.group(1)
        params = m.group("params")
        # Replace Request type in params
        new_sig = _replace_request_type_in_signature(full, request_class)
        # Heuristic request var name
        mvar = REQUEST_PARAM_RE.search(params)
        request_var = mvar.group('var') if mvar else 'request'
        # For simplicity, we won't deeply parse body per method; global validate() replacement will suffice
        return new_sig
    out = METHOD_SIG_RE.sub(replace_method, out)

    # Global body replacement (best-effort)
    mvar = REQUEST_PARAM_RE.search(content2)
    req_var = mvar.group('var') if mvar else 'request'
    out = _refactor_method_body(out, req_var)
    return out


def apply_controller_refactors(plan: Dict[str, Any]) -> Dict[str, Any]:
    applied = 0
    errors: List[str] = []
    changed_files: List[str] = []
    for item in plan.get("items", []):
        file_path = item.get("file")
        request_class = item.get("request_class")
        try:
            with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
                content = f.read()
            new_content = create_controller_refactor_diff(content, request_class)
            if new_content != content:
                # Backup
                try:
                    with open(file_path + ".bak", "w", encoding="utf-8") as b:
                        b.write(content)
                except Exception:
                    pass
                with open(file_path, "w", encoding="utf-8") as w:
                    w.write(new_content)
                applied += 1
                changed_files.append(file_path)
        except Exception as e:
            errors.append(f"{file_path}: {e}")
    return {"applied": applied, "changed_files": changed_files, "errors": errors}


def build_controller_refactor_diffs(plan: Dict[str, Any]) -> List[Dict[str, Any]]:
    diffs: List[Dict[str, Any]] = []
    for item in plan.get("items", []):
        file_path = item.get("file")
        request_class = item.get("request_class")
        try:
            with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
                old_content = f.read()
            new_content = create_controller_refactor_diff(old_content, request_class)
            if new_content != old_content:
                udiff = difflib.unified_diff(
                    old_content.splitlines(True),
                    new_content.splitlines(True),
                    fromfile=file_path,
                    tofile=file_path + " (refactored)",
                )
                diffs.append({
                    "file": file_path,
                    "diff": "".join(udiff),
                    "new_content": new_content,
                })
        except Exception:
            continue
    return diffs
